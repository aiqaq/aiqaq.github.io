[{"title":"Golang 学习笔记","path":"/2023/Go.html","content":"Golang参考Golang Golang内置类型和函数内置函数append -- 用来追加元素到数组、slice中,返回修改后的数组、slice close -- 主要用来关闭channel delete -- 从map中删除key对应的value panic -- 停止常规的goroutine （panic和recover：用来做错误处理） recover -- 允许程序定义goroutine的panic动作 real -- 返回complex的实部 （complex、real imag：用于创建和操作复数） imag -- 返回complex的虚部 make -- 用来分配内存，返回Type本身(只能应用于slice, map, channel) new -- 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针 cap -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） copy -- 用于复制和连接slice，返回复制的数目 len -- 来求长度，比如string、array、slice、map、channel ，返回长度 print、println -- 底层打印函数，在部署环境中建议使用 fmt 包 数据类型基础数据类型数组 定义数组 var arr [10]int // 定义一个长度为10的int型数组 var arr2 = [3]int&#123;1, 2, 3&#125; // 定义一个长度为3的int型数组 // 在 Javascript 中 [...] 称为扩展运算符 var arr3 = [...]int&#123;1, 2, 3&#125; // 定义一个长度为3的int型数组 var arr4 = [...]int&#123;99: -1&#125; // 定义一个长度为100的int型数组，其中第一个元素为99，其余元素为默认值0，最后一个元素为-1 var arr5 = [10]int&#123;1,2&#125; //部分元素赋值 var arr6 = [10]int&#123;1: 2, 3: 4&#125; //部分元素赋值,指定元素 多维数组var arr7 = [2][3]int&#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125; &#125; 访问与赋值 访问单个 根据元素对应下标访问var arr [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; fmt.Println(arr[0]) // 1 遍历len() 查看数组或 slice 长度cap() 查看数组或 slice 容量for k, v := range arr &#123; fmt.Printf(\"arr[%d]=%d \", k, v) &#125; // 遍历并操作每一个元素 for i := 0; i &lt; len(arr); i++ &#123; arr[i] = arr[i] * 2 &#125; 总结1.数组是值类型，只有值类型才能比较大小，比较大小的时候，会拷贝数组，拷贝的数组是不同的内存地址，所以比较的是数组的内容，而不是数组的地址2.数组是 元素类型相同 且 长度固定 的存储在内存中3.数据类型元素类型相同 且 长度固定 的数组才是同样类型的数组 // 1 var a = [3]int&#123;1, 2, 3&#125; var b = a fmt.Println(a, b) // 比较两数组指针地址 fmt.Println(&amp;a == &amp;b) // false slice（切片）切片可理解为动态长度的数组，即可以在数组的基础上增加或减少元素的个数。 定义var arr := []int&#123;1, 2, 3&#125; var arr1 := []string&#123;1:'Jerry', 3:'Tom'&#125; nil切片和空切片他们长度和容量都是0，但是它们指向底层数组的指针不一样，nil切片的指针是nil，而空切片对应的指针是个地址，换句话说表示一个空合集。var a []int&#123;&#125; // nil切片 b := []int&#123;&#125; // 空切片 声明具有容量的切片slice := make([]int, 5, 10) // 声明slice长度为5容量为10 slice1 := make([]int,10) // 声明slice长度容量一致 随笔 关于副词参数%T 显示一个值对应的数据类型 %x 显示一个值对应的十六进制值 %t 显示一个值对应的布尔值 %b 显示一个值对应的二进制值 %c 显示一个值对应的Unicode码值 %d 显示一个值对应的十进制值 %o 显示一个值对应的八进制值 %s 显示一个值对应的字符串"},{"title":"简述 HTTP","path":"/2023/HTTP.html","content":"简述HTTP什么是 HTTP ？超文本传输协议（HTTP）是基于 TCP&#x2F;IP 的应用层通信协议，用于标准化客户端和服务器之间的通信方式。 HTTP 演变历程1.HTTP 0.9 —— 1991HTTP0.9算是最早期的 HTTP 协议，也被称作单行协议，以唯一可用方法 GET 开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的） // request GET /index.html // response &lt;HTML lang=\"\">请求响应内容&lt;/HTML> 服务端接收到请求并响应数据，一旦数据被传输，此次连接关闭 只有 GET 方法 只能返回 HTML 没有头信息 2. HTTP 1.0HTTP1.0 版本对于 HTTP0.9 做出了很大的提升，以往的请求引入了 HTTP 标头的概念，协议版本会随着请求携带；请求响应中会包含状态码，响应传输的内容也不拘泥于纯 HTML 包含图片、视频、文本等其他类型的内容（凭借 content-type）。 新增请求方法 POST、HEAD 请求携带协议版本号，HTTP 标头 传输内容多样化（图片、视频、文本等） 响应状态码 // request // Host 是非必须的 GET /index.html HTTP/1.0 Host: yaqf.x2ox.com user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) // response 200 ok Date: Sat, 28 Jan 2023 14:28:26 GMT Last-modified: Sat, 30 Jul 2022 10:29:09 GMT Sever: GitHub.com Content-Type: text/html; charset=utf-8 &lt;HTML> 一个包含图片的页面 &lt;IMG SRC=\"/myimage.gif\"> &lt;/HTML> HTTP1.0 版本是一种无状态、无连接的应用层协议。 即浏览器与服务器每次保持短暂的链接，也就是每一次请求都必须建立一次 TCP 连接，服务器处理完成后就断开链接，服务器也不会维护关于客户端的信息。 正是因为 HTTP 无状态，每次连接客户端都需要携带大量冗余的数据，而每次建立 TCP 连接需要三次握手，断开 TCP 链接又需要四次挥手，这就避免不了，当面对大量的请求时，大量的 TCP 连接会降低性能。 为了避免以上问题 HTTP1.0 尝试在头信息中携带 Connection: keep-alive保持长连接，但是并未广泛使用。(关于三握四挥可以简单的理解为浏览器与服务器在建立连接之前都需相互通知一声”我准备好了！“) HTTP1.0 存在问题： 连接无法复用 队头堵塞 3. HTTP1.1HTTP1.1 在1.0版本做出了以下提升： 连接复用 在 HTTP1.1 版本下默认保持连接状态不会自动关闭，客户端需要断开连接时在请求头中携带Connection: close，客户端通常在最后一个请求中发送以达到安全关闭连接。 新增请求方法 PUT、DELETE、OPTIONS、PATCH Host 头 在 HTTP1.0 中 Host 头在请求中不是必须，在 HTTP 1.1 中是必须的 请求管线化 在 HTTP1.0 中我们知道大量的请求会导致对头堵塞，在该版本中引入了对管线化的支持，客户端可以向服务器发送多个请求，无需等待来自连接上的服务器响应。 需要注意的是服务器必须安装客户端请求的先后顺序依次响应，以保证客户端区分每次请求的相应内容。 在持久连接和管线化连接中，响应信息中头部必须携带 Content-lenght，以确保客户端知道传输何时完成，并进行下一次请求 由于多个请求必须按照顺序发送，假设现在依次发送五个请求，后三个请求响应数据均以准备好，但第一个请求由于某种原因堵塞，导致队头堵塞。 更多 4. HTTP2.0 二进制分帧 在一个 TCP 连接中的多个请求，请求和响应都将以二进制流传输，不再是之前的文本形式，每个二进制流都会有各自的流 ID（即每个请求），每个流都将划分成多个帧，每个帧都将有个流标识，标识所属流 多路连接复用 在 HTTP1.x 版本中每个请求都需要建立 TCP 连接，在2版本中所有的请求都将在一个 TCP 连接中异步发送 请求和响应都将以流和帧的形式，无需在意依次顺序，服务器以相同的异步方式响应，即响应没有顺序。客户端根据分组所属的流 ID 区分，无需等待上一次请求的响应来进行下一次请求。 头部压缩 在 HTTP1.x 版本中，HTTP 是无状态、无连接的，这就导致请求携带大量冗余数据，当同一个客户端多次访问服务器时，会携带很多相同数据（例如：header 中的 Content-type:xxx），所以会对相同部分进行压缩。 这里采用的压缩算法叫 Huffman Coding 服务器推送 指一个请求多个响应，即服务器还没有收到客户端的请求，就吧各种资源推送给客户端 5. HTTP3.0 参考：Aoang’s BlogMDN Evolution of HTTP"},{"title":"字符串匹配的KMP算法","path":"/2023/KMP算法.html","content":"参考 字符串匹配 Jack Boxer KMP 算法主要是来匹配某一串字符中是否包含另一串字符串？例：”abababca” 中是否包含 “abc”，但是不同于普通的匹配字符串的方法来看，普通匹配是遍历字符串的每一项与目标字符串逐一比较，遇到不匹配的回滚重新匹配。而 KPM 算法本质上也是遍历字符串，但是会有所提高效率，KMP 算法避免了已经比对过的字符串部分还需要重新比对，而是能接着往下进行。 下面有一串字符 “bacbababaabcbab” ，我们需要找出 “abababca” 是否存在于里面 首先我们先来了解一下前缀（proper prefixes）&#x2F;后缀的概念（proper suffixes）前缀：不包含自身的前面的全部字串，例 “abab” 的前缀有 “a”,”ab”,”aba”后缀：不包含自身的后面的全部字串，例 “abab” 的后缀有 “b”,”ab”,”bab” 而我们KMP算法比对的关键就是这个 prefix 数组，也就是我们需要知道已对比字符串的前后缀最大相同长度 移动位数 = 已匹配的字符数 - 对应的部分匹配值 a 0 ab 0 aba 1 (前后缀都是 a, 相等长度为1) abab 2 ababa 3 ababab 4 abababc 0 abababca 1 index: 0 1 2 3 4 5 6 7 char: a b a b a b c a prefix: 0 0 1 2 3 4 0 1 第一次比对：首字母 a 和上面 b 不匹配，后移一位 b a c b a b a b a a b c b a b | a b a b a b c a 0 0 1 2 3 4 0 1 第二次比对：首字母 a 和上面 a 匹配，继续匹配,c 和 b 不匹配，b 所对应的字符的prefix数组对应的值是 0 b a c b a b a b a a b c b a b | x a b a b a b c a 0 0 1 2 3 4 0 1 // 这里已经同理比对了 3 次 b a c b a b a b a a b c b a b | x x x a b a b a b c a 0 0 1 2 3 4 0 1 第五次：此时已经比对成功了5个字符，第6位 b 比对失败，5(已匹配字符数) - 3(prefix[4]) &#x3D; 2 b a c b a b a b a a b c b a b | | | | | x a b a b a b c a 0 0 1 2 3 4 0 1 x // 依旧不匹配 3(已匹配字符数) - (prefix[2]) = 2 a b a b a b c a 0 0 1 2 3 4 0 1 x // 依旧不匹配，匹配长度超出 origin 字符串长度，查询无果 a b a b a b c a 0 0 1 2 3 4 0 1 手写prefix数组"},{"title":"React 学习笔记","path":"/2023/React.html","content":"条件渲染不同于 Vue 框架的条件渲染，React 中使用 JavaScript 运算符 if 或者条件运算符去创建元素实现思路：根据不同状态动态 return Dom 元素交给 render 渲染 jsxfunction Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if (isLoggedIn) &#123; return &lt;UserGreeting />; &#125; return &lt;GuestGreeting />; &#125; const root = ReactDOM.createRoot(document.getElementById('root')); // Try changing to isLoggedIn=&#123;true&#125;: root.render(&lt;Greeting isLoggedIn=&#123;false&#125; />); 元素变量自定义变量来存储状态，有条件的渲染组件的某部分，React的原则就是只渲染需要渲染的部分 jsx// 参考官网示例 // 点击不同按钮修改变量状态，选择性渲染对应部分 class LoginControl extends React.Component &#123; constructor(props) &#123; super(props); this.handle1= this.handle1.bind(this); this.handle2 = this.handle2.bind(this); this.state = &#123;isLogin: false&#125;; &#125; handle1() &#123; this.setState(&#123;isLogin: true&#125;); &#125; handle2() &#123; this.setState(&#123;isLogin: false&#125;); &#125; render() &#123; const isLogin = this.state.isLogin; let button; if (isLogin) &#123; button = &lt;LogoutButton onClick=&#123;this.handle1&#125; />; &#125; else &#123; button = &lt;LoginButton onClick=&#123;this.handle2&#125; />; &#125; return ( &lt;div> &lt;Greeting isLoggedIn=&#123;isLogin&#125; /> &#123;button&#125; &lt;/div> ); &#125; &#125; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(&lt;LoginControl />); 内联条件渲染 与运算符 &amp;&amp; 三目运算符(三元) 阻止组件渲染 jsx// &amp;&amp; 如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。 &lt;div> &lt;h1>Hello!&lt;/h1> &#123;unreadMessages.length > 0 &amp;&amp; &lt;h2> You have &#123;unreadMessages.length&#125; unread messages. &lt;/h2> &#125; &lt;/div> // 三元 &lt;div> &#123;isLoggedIn ? &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /> : &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /> &#125; &lt;/div> // 在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 render 方法直接返回 null，而不进行任何渲染。 function WarningBanner(props) &#123; if (!props.warn) &#123; return null; &#125; return ( &lt;div className=\"warning\"> Warning! &lt;/div> ); &#125; class Page extends React.Component &#123; render() &#123; return ( &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /> ) &#125; &#125; React.Component参考学习理解 React class 组件的前提是熟悉组件 &amp; props，以及State &amp; 生命周期等 首先 React 组件有两种形式,class 类组件和普通函数组件 函数组件jsx// 定义 function Page(props)&#123; return &lt;div>Hello,&#123;props.name&#125;&lt;/div> &#125; 类组件jsxclass Page extends React.Component &#123; render() &#123; return &lt;div>Hello,&#123;this.props.name&#125;&lt;/div> &#125; &#125; 函数组件和类组件区别参考 语法 函数式组件，接受 props 参数，返回 react 元素 类组件，需要继承 React.Component 并且创建 render 返回 react 元素 状态管理 函数式组件又称为无状态组件，不能直接使用setState()，若使用可以创建类组件或者将 state 提升到父组件通过 props 传递，不过在 react16.8 版本中添加了 hook ，函数组件中可以使用 useState 钩子去管理 state,使用useEffect 去使用生命周期函数 类组件参考 生命周期函数 参考 React16.8 调用方式 函数组件本质是函数，需要调用 类组件调用前需要先实例化再调用 render 渲染 可想而知，函数组件重新渲染将重新调用组件方法返回新的 react 元素，类组件重新渲染将 new 一个新的组件实例，然后调用 render 类方法返回 react 元素，这也说明为什么类组件中 this 是可变的。 获取渲染时的值jsx// 函数组件中的 this 是函数本身 function Page(props)&#123; alert('time', props.time) &#125;"},{"title":"TypeScript使用手册","path":"/2023/TypeScript.html","content":"日常类型string number boolean 使用和 JavaScript 使用上没区别，不指定类型会隐式转换，一般用于 interface 接口中指定类型 array 指定 [1,2,3] 例：number[] Array[number] 属于 元组类型 （另一种 Array 类型）确切的知道包含多少个元素，以及它在特定位置包含哪些类型 [string, number] 表示索引为 0 的是 string 类型，索引为 1 的是 number 类型，如果书写 [12] 会抛出错误，Tuple type &#39;[string, number]&#39; of length &#39;2&#39; has no element at index &#39;2&#39;.元组本质就是数组，所以我们可以使用 JavaScript 的 es6 中 解构元组(数组解构是顺序解构，可以默认值) 可选元组 详情见官网Either2dOr3d = [number, number, number] // length 取决于可选参数是否定义，是否存在(number | undefined) 那这种固定类型固定长度的元组可否自定义？可，只不过里面的子项必须也是元组&#x2F;数组类型 例：[ string, number, …boolean[] ],也可以自定义一个interface参考 只读 readonly,相当于const声明function doSomething(pair: readonly [string, number]) &#123; pair[0] = \"hello!\" // Cannot assign to '0' because it is a read-only property. &#125; any不指定具体类型，根据最后元素类型而定no implicit any将任意隐式标记为any错误 类型变量注释当你使用 const var let 声明变量时，可以添加类型注释const info: string = &#39;qiuqiu&#39;;但是一般情况下不需要，因为会根据你的代码进行隐式转换。但是值得注意的是当进行请求回来数据接收的时候，如果没有进行类型变量注释，很可能在数据还没有回来的情况下出现 undefinedInfo是我们请求回来的数据，type为object,我们需要使用Info里面的方法或属性Info.fun()此时会报错undefined无法调用，这就需要我们断言 Function与 JavaScript 不同的是对于函数传递的参数可以指定类型，以及返回值类型，其中返回值类型也可以参考 泛型，当然我们不需要返回内容或者不需要指定返回参数类型的时候是不需要指定类型的 参数指定类型 返回值指定类型 任意类型(隐式转换)interface Result&lt;T> &#123; code: number, msg: string, data?: T &#125; class AuthClass &#123; Login(req: LoginRequest): Promise&lt;Result&lt;AuthToken>> &#123; return client.post(V1 + '/auth/login', req).then(result => &#123; return result.data &#125;).catch(err => &#123; return &#123; code: -1111, msg: err &#125; &#125;) &#125; &#125; Object Types参考依赖 JavaScript 中 Object 类型所有属性 可选属性 使用方式 last?: string 表示可传可不传，因为在 JavaScript 中访问对象不存在属性的时候是会报 undefined 的 error，所以当使用可选属性的时候需要做一下判断，是否为 undefinedfunction printName(obj: &#123; first: string; last?: string &#125;) &#123; // Error - might crash if 'obj.last' wasn't provided! console.log(obj.last.toUpperCase()); // Object is possibly 'undefined'. if (obj.last !== undefined) &#123; // OK console.log(obj.last.toUpperCase()); &#125; // A safe alternative using modern JavaScript syntax: console.log(obj.last?.toUpperCase()); &#125; Union Types 联合类型你可以定义一个类型，是由两个或者多个类型组成，你定义的该类型只要符合其中一个皆可，这个类型则称为联合类型，而里面的每一个子类型称为联合成员 声明使用 id: number | stringfunction printId(id: number | string) &#123; console.log(\"Your ID is: \" + id); &#125; // OK printId(101); // OK printId(\"202\"); // Error printId(&#123; myID: 22342 &#125;); Argument of type &#39;&#123; myID: number; &#125;&#39; is not assignable to parameter of type &#39;string | number&#39;. Interface可以理解为以接口形式声明对象类型 声明使用interface Test&#123; type:string &#125; interface UserNum&#123; data:number[] &#125; export interface Test1 extends Test&#123; name:string; scope:UserNum; [key: string]: number // key-value 结构类型声明 &#125; Partial 可选参数属性 Required 属性必选 Readonly 属性只读 例：Readonly&lt; Test &gt; TypeType 类型可以通过书写联合类型或对象类型来直接使用，通常情况下会多次使用同一类型并通过一个名字引用 声明使用// 对象类型 type Stu = &#123; name:'Tom'; sex:'boy' &#125; console.log(Stu.name) // 联合类型 type StuID = number | string Type 和 Interface 的区别 extends 参考Type 类型在定义时就已经限定，无法后续添加属性Interface 类型可以在自身基础上去继承其他 interface 上的其他属性 类型断言某些情况下 Typescript 不清楚当前类型，会报错，此时可以使用 as 进行类型断言 使用const myHome = GetMy() as string const let var尽可能用 let 代替 var let 仅限于块级作用域使用，可以再次被赋值 const 在 let 之上做了一个增强，声明后不允许被再次赋值 undefined 和 null 出现的情况// 函数不确定返回值 function sum():void&#123; &#125; // 可选参数 interface Sum&#123; num?:number; // num: number | null name:string &#125; // 当使用 Sum 接口时，可选参数num没有传递，Typescript可能会提示 num 是 undefined 或 null // 此时可使用 ！ 表示声明这个属性一定存在 枚举我们可以理解枚举为声明一些命名常量的集合，有数字类型枚举和字符串枚举 定义与使用 数字类型枚举 enum CardSuit &#123; Clubs, // 0 Diamonds, // 1 Hearts, // 2 Spades // 3 &#125; // 默认会从 0 依次递增 // 如果初始化 Clubs = 3 则后面成员在 3 基础上依次递增 字符串类型枚举enum Direction &#123; Up = \"UP\", Down = \"DOWN\", Left = \"LEFT\", Right = \"RIGHT\", &#125; 静态方法的枚举参考理解类和继承里面访问静态方法 enum Weekday &#123; Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday &#125; namespace Weekday &#123; export function isBusinessDay(day: Weekday) &#123; switch (day) &#123; case Weekday.Saturday: case Weekday.Sunday: return false; default: return true; &#125; &#125; &#125; const mon = Weekday.Monday; const sun = Weekday.Sunday; console.log(Weekday.isBusinessDay(mon)); // true console.log(Weekday.isBusinessDay(sun)); 开放式枚举enum Color &#123; Red, Green, Blue &#125; enum Color &#123; DarkRed = 3, // 一定要重新初始化第一个成员的值，否则报警告 DarkGreen, DarkBlue &#125; 类型和 new new 可用于普通变量声明更多了解 高级类型交叉类型交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。"},{"title":"Cookie 支持","path":"/2023/cookies_support.html","content":"参考： HTTP Cookie Cookie Support什么是 Cookie？ Cookie 是存储在浏览器上的一块数据，网页指示浏览器在首次访问时存储信息，当用户返回网站时，cookie 将添加到 HTTP 标头中（浏览器的自动行为）。 Cookie 的存储以键值对的形式例如yummy_cookie=choco（计为一个），包括实际数据、cookie 过期时间，发送到目标服务器的域和路径。 Cookie 同样遵循浏览器的同源策略，cookie 只能由来自同一网站的页面访问，即域、协议、端口必须一致。 Cookie 的限制标准网页存储 Cookie 的大小依照不同浏览器而定，不同浏览器对于 Cookie 数量及大小有一定地限制。参考IETF cookie规范 每个 Cookie 至少 4096 byte 单个域的 Cookie 至少 50 个 Cookie 总数至少 3000 浏览器限制其中个数指的是键值对个数例&#96;yummy_cookie&#x3D;choco，单个域的 Cookie 总大小不得超过4096如果 cookie 超过浏览器限制，则会出现以下问题 任何大小大于限制的 cookie 都会被忽略（而不是设置） 达到限制，将删除最古老的 cookie 以存储新cookie 如果计算机没有足够的空间来存储 cookie 它将被丢弃"},{"title":"tsconfig 配置文件中关于 jsx 配置项？","path":"/2023/tsconfig-reference.html","content":"参考：tsconfig reference当在 React 中使用 TypeScript 时，tsconfig.json 文件中会有专门配置 jsx 转义的字段, 控制着 jsx 结构在 js文件中的输出，这只会影响着.tsx文件输出 js 文件。 &#123; \"compilerOptions\": &#123; // 它具有 \"react-jsx\" | \"react\" | \"react-native\" | \"preserve\" | \"react-jsxdev\" 作为允许值 \"jsx\": \"react-jsx\" &#125; &#125; react: 将使用 jsx 的 .js 文件更改为等效的 React.createElement 调用 react-jsx: 将使用 jsx 的 .jsx 文件更改为调用 _jsx react-jsxdev: 将使用 jsx 的 .jsx 文件更改为调用 _jsx preserve: 输出保留 jsx .jsx 文件 react-native: 输出没做更改 jsx 的 .jsx 文件 example:// 基于同一段 jsx 语法不同配置下的输出 export const HelloWorld = () => &lt;h1>hello world&lt;/h1> // 默认是 \"react\" import React from 'react' export const HelloWorld = () => React.createElement(\"h1\", null, \"hello world\") // \"preserve\" | \"react-native\" import React from 'react'; export const HelloWorld = () => &lt;h1>Hello world&lt;/h1>; 当我们使用 jsx 语法，编译器通过调用 React.createElement() 将 jsx 转换成浏览器所能理解的 HTML元素，然而 React 官方也提到 React.createElement() 是当时旧版本中用来转义 jsx 的一个工具，并没用成为 jsx 的实现，并且存在其他不允许的性能改进和简化。为了解决这些问题，React 17 引入了两个新的 React 包入口点，打算仅供 Babel 和 TypeScript 等编译器使用。 ** 因此最好使用 “react-jsx” ** // \"react-jsx\" import &#123;jsx as _jsx&#125; from \"react/jsx-runtime\"; import React from 'react'; export const HelloWorld = () => _jsx(\"h1\", &#123;children: \"Hello world\"&#125;); // \"react-jsxdev\" import &#123;jsxDEV as _jsxDEV&#125; from \"react/jsx-dev-runtime\"; const _jsxFileName = \"/home/runner/work/TypeScript-Website/TypeScript-Website/index.tsx\"; import React from 'react'; export const HelloWorld = () => _jsxDEV(\"h1\", &#123;children: \"Hello world\"&#125;, void 0, false, &#123; fileName: _jsxFileName, lineNumber: 9, columnNumber: 32 &#125;, this);"}]